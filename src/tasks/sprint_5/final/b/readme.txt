-- ПРИНЦИП РАБОТЫ --
Алгоритм удаляет узел с заданным ключом из бинарного дерева поиска (BST), сохраняя свойства дерева.
Основные этапы работы:
1) Выполняется поиск узла с заданным ключом и его родителя с помощью функции findNode.
2) Если узел не найден, то дерево остаётся без изменений.
3) Если узел найден:
    - Если у узла 0 или 1 ребенок, узел заменяется на существующего ребёнка (или на null, если детей нет) с помощью функции removeNode.
    - Если у узла 2 ребенка, ищется преемник (минимальный элемент в правом поддереве), значение узла заменяется на значение преемника, а преемник удаляется рекурсивно через remove.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Корректность обеспечивается свойствами BST и правильной реализацией удаления:
- Функция findNode корректно находит узел и его родителя.
- Для узла с 0 или 1 ребенком операция замены на ребенка сохраняет свойства BST.
- Для узла с 2 детьми замена на преемника гарантирует, что все значения в левом поддереве меньше, а в правом — больше, что сохраняет свойства BST.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
- n - количество узлов в дереве, h - высота дерева.
Поиск узла: O(h)
Удаление узла с 0 или 1 ребенком: O(1)
Удаление узла с 2 детьми: O(h) (поиск преемника + удаление преемника)
Итоговая временная сложность: O(h)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
- h - высота дерева
Дополнительная память используется только для рекурсивных вызовов: O(h) стек вызовов
Новые узлы не создаются
Итоговая пространственная сложность: O(h)