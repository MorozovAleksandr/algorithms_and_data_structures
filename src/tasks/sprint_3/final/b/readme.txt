-- ПРИНЦИП РАБОТЫ --
В quick sort in place я беру опорный(pivot) элемент из центра массива, именно значение этого элемента, которое используется для сравнения.
Также есть два указателя, двигаю указатели пока не нахожу элемент слева который нужно переставить в правый сегмент,
а справа который нужно переставить в левый сегмент, меняю элементы местами.
Алгоритм продолжает работу, пока tempLeft не превысит tempRight, и затем рекурсивно сортирует оставшиеся части

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Сортировка будет рекурсивно вызываться, пока все сегменты не будут отсортированны
Все элементы слева от tempLeft будут меньше или равны pivot, а справа от tempRight — больше или равны pivot

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
- n - количество элементов в массиве
В среднем случае сложность O(n log n), в худшем случае имеет сложность n^2

Итоговая временная сложность программы: - n^2

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
- m - глубина рекурсии
Алгоритм использует константное дополнительное пространство для переменных O(1),
Стек вызовов рекурсии имеет пространственную сложность в среднем O(log m), а в худшем O(m)

Итоговая пространственная сложность - O(m)
