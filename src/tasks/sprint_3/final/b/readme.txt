-- ПРИНЦИП РАБОТЫ --
В quick sort in place я беру опорный(pivot) элемент из центра массива, именно значение этого элемента используется для сравнения.
Также есть два указателя, двигаю указатели пока не нахожу элемент слева который нужно переставить в правый сегмент,
а справа который нужно переставить в левый сегмент, меняю элементы местами.
Алгоритм продолжает работу, пока tempLeft не превысит tempRight, и затем рекурсивно сортирует оставшиеся части.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Сортировка будет рекурсивно вызываться, пока все сегменты не будут отсортированны.
Все элементы слева от tempLeft будут меньше или равны pivot, а справа от tempRight — больше или равны pivot.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
- n - количество элементов в массиве
Сложность зависит от выбора опорного элемента, в идеальном данные делятся примерно пополам на каждом уровне рекурсии.
Худший случай произойдет, когда опорный элемент будет началом или концом отсортированного массива.
В среднем случае сложность O(n log n), в худшем случае имеет сложность n^2.

Итоговая временная сложность программы: - n^2

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
- n - количество элементов в массиве
Сложность зависит от выбора опорного элемента, в идеальном данные делятся примерно пополам на каждом уровне рекурсии.
Худший случай произойдет, когда опорный элемент будет началом или концом отсортированного массива.
Алгоритм использует константное дополнительное пространство для переменных O(1).
Стек вызовов рекурсии имеет пространственную сложность в среднем O(log n), а в худшем O(n).

Итоговая пространственная сложность - O(n)
