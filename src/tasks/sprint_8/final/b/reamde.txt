-- ПРИНЦИП РАБОТЫ --
Алгоритм проверяет, можно ли строку text разбить на последовательность слов из заданного словаря dict.
1) Создаётся массив dp длиной text.length + 1, где dp[i] означает, что первые i символов строки можно разбить на слова из словаря.
2) Изначально dp[0] = true, так как пустую строку можно считать корректно разбитой.
3) Для каждой позиции i в строке алгоритм проверяет все слова словаря:
 - Если слово может завершаться в позиции i и предыдущая часть строки (dp[i - len]) разбивается корректно,
 - И если подстрока text[i-len..i] совпадает с этим словом, то dp[i] становится true.
4) После обработки всей строки значение dp[text.length] показывает, можно ли всю строку разбить на слова из словаря.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Алгоритм корректен, потому что:
1) Каждая позиция i в массиве dp учитывает все возможные слова, которые могут завершаться в этой позиции.
2) dp[i] = true только если существует хотя бы один способ разбить первые i символов на слова из словаря.
3) Итоговое значение dp[text.length] проверяет, можно ли всю строку составить из слов словаря, что полностью соответствует условию задачи.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
- n — количество слов в словаре
- m — длина строки text
- L — максимальная длина слова в словаре
В худшем случае для каждой позиции i проверяется каждый элемент словаря и сравниваются подстроки длиной до L.
Итоговая сложность: O(m * n * L)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
- n — количество слов в словаре
- m — длина строки text
Массив dp размера m + 1 для хранения информации о разбиении строки -> O(m), где m - длина строки text.
Словарь для хранения всех слов -> O(суммарная длина всех слов в словаре), то есть сумма длин всех n слов.
Итоговая пространственная сложность: O(m + суммарная длина всех слов словаря)