-- ПРИНЦИП РАБОТЫ --
Алгоритм проверяет, можно ли строку text разбить на слова из заданного словаря, используя префиксное дерево (Trie) для эффективного поиска.
1) Построение Trie: Все слова из словаря добавляются в префиксное дерево. Каждый узел дерева представляет собой символ, а флаг isEnd в узле показывает, что путь от корня до этого узла образует слово из словаря.
2) Создается массив dp длиной n + 1 (где n - длина строки text). dp[0] = true, так как пустую строку можно считать корректно разбитой.
3) Для каждой позиции i в строке алгоритм проверяет все слова словаря:
 - Если слово может завершаться в позиции i и предыдущая часть строки (dp[i - len]) разбивается корректно,
 - И если подстрока text[i-len..i] совпадает с этим словом, то dp[i] становится true.
4) После обработки всей строки значение dp[text.length] показывает, можно ли всю строку разбить на слова из словаря.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Алгоритм корректен, потому что:
1) Каждая позиция i в массиве dp учитывает все возможные слова, которые могут завершаться в этой позиции.
2) dp[i] = true только если существует хотя бы один способ разбить первые i символов на слова из словаря.
3) Итоговое значение dp[text.length] проверяет, можно ли всю строку составить из слов словаря, что полностью соответствует условию задачи.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
- n - количество слов в словаре
- m - длина строки
- L - максимальная длина слова в словаре
- S - суммарная длина всех слов в словаре
Построение префиксного дерева: O(S)
В худшем случае для каждой из m позиций мы можем пройти по дереву на глубину до L: O(m * L)
Итоговая сложность: O(S + m * L)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
- n - количество слов в словаре
- m - длина строки
- S - суммарная длина всех слов в словаре
Префиксное дерево: O(S) - для хранения всех узлов дерева
Массив dp: O(m) - для хранения информации о разбиении строки
Итоговая пространственная сложность: O(S + m)