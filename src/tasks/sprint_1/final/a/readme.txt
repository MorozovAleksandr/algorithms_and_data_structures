-- ПРИНЦИП РАБОТЫ --
Для решения данной задачи, я реализовал два цикла для прохода (слева направо и справа налево) по массиву.
Первый проход (слева направо) считает расстояние до последнего встреченного нуля слева и инициализирует массив,
Второй проход (справа налево) обновляет расстояние, если справа есть более близкий 0.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Первый проход гарантирует корректность для 0 слева, а второй — для 0 справа,
и при необходимости обновляет значение до ближайшего.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Алгоритм - distanceToZero
Проход циклом по массиву стоит O(n), мы используем два цикла
Операции внутри цикла O(1)
Так как при подсчете сложности константы не учитываются конечная сложность алгоритма - O(n)

Вспомогательная функция - getString
Сложность - O(1)

Вспомогательная функция - getArray
Создаем и заполняем массив сложность - O(n)

Итоговая временная сложность программы: - O(n)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Массив houseNumbers - O(n)
Основной дополнительный массив distance — O(n)
Временные переменные (lastZero, i, j) — O(1)
Вывод результата result.join(' ') - O(n)

Итоговая пространственная сложность - O(n)
